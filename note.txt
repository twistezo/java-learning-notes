KLASA - "szablon" dla obiektów. Zawiera pola, metody, konstruktory, bloki kodu

METODA- ci¹g instrukcji realizuj¹cych dan¹ funkcjê

OBIEKT- rzeczywista reprezentacja klasy

KONSTRUKTOR- kod uruchamiany w trakcie tworzenia nowej instancji klasy. Brak typu. Nazwa taka jak nazwa klasy

PAKIET- pogrupowany zbiór klas

DZIEDZICZENIE- przejmowanie metod i zmiennych od klasy "rodzica". Mo¿na implementowaæ kilka interfejsów, ale dziedziczyæ tylko jedn¹ klasê.

POLIMORFIZM- wi¹zanie podobnych obiektów np. za pomoc¹ interfejsu

ENKAPSULACJA - ukrywanie danych poprzez tworzenie prywatnych pól i getterów/setterów do nich

MECHANIZM REFLEKSJI - proces, w którym program mo¿e byæ modyfikowany w trakcie wykonywania

INTERFEJS - klasa zawieraj¹ca zmienne oraz metody (bez implementacji). Mówi CO obiekt ma robiæ, nie mówi JAK. Dziedzic musi nadpisaæ wszystkie metody.

KLASA ABSTRAKCYJNA- klasa, z której nie mo¿na stworzyæ obiektu. Trzeba j¹ dziedziczyæ. Mo¿e posiadaæ metody abstrakcyjne - bez implementacji (dziedzic musi je przes³oniæ). Nie mo¿e byæ finalna, ani mieæ statycznych metod abstrakcyjnych.

MODYFIKATORY DOSTÊPU:
-public
-protected (klasy dziedzicz¹ce)
-private (klasa)
-default (pakiet)

TYPY PRYMITYWNE
-byte (8 bit - 2^7 - 128)
-short (16-bit - 2^15 - 32 000)
-int (32 bit - 2^31 - 2 miliardy)
-long (64 bit - 2^63)
-float (32 bit - 0.0f)
-double (64 bit - 0.0d)
-boolean
-char

STATIC - zmienna, metoda, blok lub klasa statyczna -  posiadaj¹ca tylko jedn¹ instancjê (miejsce w pamiêci). Odwo³ujemy siê bez inicjowania klasy.

FINAL:
-pole 'final' nie mo¿e byæ modyfikowane
-z klasy 'final' nie mo¿na dziedziczyæ
-metody 'final' nie mo¿na przes³oniæ

? : operator - 'max (a>b) ? a :b' jeœli a > b, max = a, w przeciwnym razie max = b

VAR-ARG- operator pozwalaj¹cy przes³aæ do metody zmienn¹ liczbê argumentów danego typu np. void print(int... numbers)

WYJ¥TKI:
-CHECKED EXCEPTIONS (czasu kompilacji). Nale¿y je wy³apaæ 'try-catch' lub przepuœciæ 'throws'
-UNCHECKED/ RUNTIME EXCEPTIONS (czasu wykonania). Np. b³êdy logiki
-error - maszyna wirtualna, œrodowisko np. OutOfMemoryException

ANONIMOWA KLASA WEW. - deklaracja i jednoczesna inicjalizacja. Czêsto s³u¿y do nadpisywania metod innych klas lub interfejsów.

'THIS :
-kiedy chcemy zmieniæ wartoœæ pola bêd¹cego argumentem metody 'void setName(String name) { this.name  = name; }
-przekazanie bie¿¹cej klasy do argumentu metody 'foo.barMethod(this);'
-wezwanie z konstruktora innego konstruktora w obrêbie klasy

'SUPER' :
-wywo³anie metody z podklasy 'super.barMethod();'
-wywo³anie konstruktora z podklasy

KOLEKCJE:
ARRAY - tablica ze znan¹ d³ugoœci¹ 'int[] foo = new int[5]'
LIST(uporz¹dkowany, dostêp losowy, duplikaty)
-ArrayList - dynamiczny rozmiar, szybki dostêp
-LinkedList - szybsza kiedy dodajemy element [0] oraz kiedy dodajemy lub usuwamy kolejny iteratorem
SET (nieuporz¹dkowany, dostêp iteratorem, brak duplikatów) :
-HashSet - wykorzystuje hashCode() do organizacji danych, zbiór nieposortowany
-TreeSet - zbiór posortowany, wolniejsze operacje
QUEUE (kolejka / bufor : FIFO lub FILO-stos) :
-ArrayDeque - dynamiczny rozmiar, FIFO
-PriorityQueue - najpierw wa¿niejsze, kryterium wg komparatora
-Stack - LIFO

MAP (unikalny klucz - wartoœæ) :
-HashMap - wykorzystuje hashCode() do organizacji danych, losowa iteracja
-TreeMap - elementy posortowane wg klucza, nielosowa iteracja
-LinkedHashMap - iteracja w kolejnoœci dodawania elementów

TYPY GENERYCZNE - parametryzowanie klasy, metody, interfejsu. Dziêki temu mo¿emy np. stworzyæ metodê, która mo¿e sortowaæ typ String, typ Int itd. '<E> void sort(E[] array) { }'

SERIALIZACJA - mechanizm zapisywania pliku do postaci binarnej 'class Foo implements Serializable'.  Wykluczenie pola - 'private transient int age'

W¥TKI
Domyœlnie JVM losowo przydziela czas i kolejnoœæ w¹tków. Mo¿na ustawiaæ priorytety.
SPOSOBY:
- dziedziczenie z klasy Thread - samodzielne zarz¹dzanie, z³y sposób
- implementacja interfejsu Runnable i u¿ycie klasy Thread do uruchomienia 'class Foo implements Runnable { public void run() {...} } -> Foo bar = new Foo();  Thread t = new Thread(bar);  t.start();

SYNCHRONIZACJA W¥TKÓW (uniemo¿liwia wy³¹czenie w¹tku zanim kod siê nie wykona)
-synchronizacja metody -> 'public synchronized void foo( ) { ... }'
-synchronizacja bloku -> 'synchronized  (Foo) { ... }' - Foo to zablokowany obiekt

'VOLATILE' - oznaczenie pola tym s³owem powoduje, ¿e w programie wielow¹tkowym, ka¿dy w¹tek chc¹cy skorzystaæ z pola zawsze posiada jego aktualn¹ wartoœæ.

DEADLOCK- w¹tki czekaj¹ na siebie w nieskoñczonoœæ

GARBAGE COLLECTOR - program JVM czyszcz¹cy pamiêæ (stertê) z nieu¿ywanych obiektów. Nie mamy na ni¹ wp³ywu. Mo¿na tylko zasugerowaæ czyszczenie.

Zmienne prymitywne 'int, long' s¹ przekazywane przez aktualn¹ wartoœæ.
Obiekty s¹ przekazywane przez wartoœæ, któr¹ jest referencja.

STOS (stack)
-s¹ na nim trzymane zmienne (wartoœci lub referencje)
-uwaga: jeœli zmienna jest lokalna typu prostego (int, long) to wyl¹duje bezpoœrednio na stosie - tj. wraz z wartoœci¹
-stos siê sam czyœci (LIFO- Last In, First Out)
-szybszy
STERTA (heap)
-s¹ na nim trzymane obiekty (wartoœci zmiennych ze stosu)
-czyœci j¹ garbage collector
-wolniejsza

WZORCE:
-SINGLETON- dziêki niemu mo¿emy stworzyæ tylko jedn¹ instancjê obiektu i wywo³ywaæ go globalnie. Statyczna metoda do pobierania instancji i prywatny konstruktor.
-FABRYKA- tworzymy interfejs do tworzenia obiektów oraz klasê fabryka, która go implementuje i tworzy konkretne obiekty jednego typu (rodziny). Plusem jest ukrycie szczegó³ów implementacji klas.
-FASADA- pomiêdzy logik¹, a klientem tworzymy klasê fasady, dziêki której klient nie wywo³uje metod bezpoœrednio z logiki. Zalet¹ jest zmniejszenie zale¿noœci.
-MVC- oddzielamy w aplikacji warstwê modelu (logiki), widoku (wyœwietlanie) i kontrolera odpowiedzialnego za interakcjê. Mode <-> Kontroler -> Widok
-DI - Dependency Injection - wstrzykiwanie zale¿noœci. Pozwala na tworzenie luŸniejszych powi¹zañ miêdzy obiektami. Wstrzykujemy gotowe instancje obiektów poprzez konstruktor 'Foo(Bar bar) {this.bar = bar;}, metodê set 'public void setBar(Bar bar) {this.bar = bar;}' lub przez interfejs z metod¹ set. W Springu procesem wstrzykiwania zajmuje siê kontener IoC (Inversion of Control).

TESTY
JUnit - biblioteka do testów jednostkowych. Adnotacja @Test i metoda np. 'assertEquals(expected value, actual value);'
Mockito - biblioteka do testowania poprzez tworzenie symulowanych obiektów (mocków)

AOP - Aspect Oriented Programming. Rozdzielanie programu na czêœci/modu³y w jak najwiêkszym stopniu.

SOAP - Simple Object Access Protocol. Standard przekazywania danych oparty o wymianê XML/JSON poprzez wys³anie pliku na serwer, który go parsuje i wykonuje jak¹œ akcje.

REST - REpresentational State Transfer. Protokó³ komunikacji bazuj¹cy na tym, ¿e protokó³ HTTP posiada kilka czasowników (GET, POST, PUT, DELETE..). Wystawiamy pod adresem URL plik XML/JSON i dziêki czasownikom HTTP mo¿emy modyfikowaæ dane na serwerze.

ORM - Obiect-Relational Mapping. Mapowanie obiektowo-relacyjne. Odwzorowanie OOP na bazê danych.

JPA/Hibernate - frameworki do ORM. Modelujemy ORM adnotacjami lub plikami XML. Relacje OneToOne, ManyToOne, OneToMany, ManyToMany.
Przyk³ad relacji:  Employee has many phones -> 'class Phone { .. @ManyToOne private Employee owner; } ... class Employee { .. @OneToMany(mappedBy="owner") private List<Phone> phones; '
Przyk³ad zapytania: 'List<Bar> findAllById(Long id);'

ALGORYTMY SORTOWANIA (od najszybszego):
-BUBBLESORT - porównujemy dwa kolejne elementy i w razie potrzeby zamieniamy je -> zapêtlamy
-QUICKSORT - wybieramy element rozdzielaj¹cy tablicê na dwa fragmenty. Wszystkie elementy mniejsze przenosimy do pocz¹tkowego, a wiêksze do koñcowego. Nastêpnie sortujemy w ten sam sposób pocz¹tkowy i koñcowy -> zapêtlamy

REKURENCJA (rekursja) - wywo³anie funkcji przez sam¹ siebie. Mo¿na ³atwo przepe³niæ stos.
Przyk³ad silni: public int silnia(int i) {if (i==0) return 1; else return i*silnia(i-1);} -> sout(s.silnia(10);
